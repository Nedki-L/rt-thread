# Automation utest run script for the QEMU platform
# Generate the corresponding config configuration for CI based on the configuration file under .github/utest.

name: action_auto_utest

on:
  push:
    branches:
      - master
    paths-ignore:
      - documentation/**
      - '**/README.md'
      - '**/README_zh.md'
  pull_request:
    branches:
      - master
    paths-ignore:
      - documentation/**
      - '**/README.md'
      - '**/README_zh.md'

permissions:
  contents: read

jobs:
  prepare:
    runs-on: ubuntu-latest 
    outputs:
      config_files: ${{ steps.set-configs.outputs.config_files  }}
    steps:
      - uses: actions/checkout@v4 
        with:
          fetch-depth: 0 
          ref: ${{ github.head_ref  }}
 
      - name: Get changed files via GitHub API 
        id: changed-files 
        run: |
          # 修复点1：处理换行符问题 
          response=$(curl -s \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{  github.repository  }}/pulls/${{ github.event.pull_request.number  }}/files")
          
          # 将换行符转换为空格 
          changed_files=$(echo "$response" | jq -r '.[].filename' | tr '\n' ' ')
          
          # 修复点2：安全写入环境变量 
          echo "CHANGED_FILES=${changed_files}" >> $GITHUB_ENV 
          echo "已获取变更文件列表：${changed_files}"
 
      - name: Determine relevant configs 
        id: set-configs 
        env:
          CHANGED_FILES: ${{ env.CHANGED_FILES }}
        run: |
          # 创建临时脚本文件 
          SCRIPT_FILE=$(mktemp /tmp/find_configs.py) 
          
          # 写入Python脚本内容（注意缩进格式）
          cat > $SCRIPT_FILE << 'PYTHON_EOF'
          import json 
          import os 
          import fnmatch 
          import sys 
           
          def main():
              try:
                  # 配置路径检查 
                  config_path = '.github/utest/config_paths.json' 
                  if not os.path.exists(config_path): 
                      print(f"[ERROR] 配置文件 {config_path} 不存在")
                      sys.exit(1) 
                      
                  with open(config_path) as f:
                      config_mappings = json.load(f) 
                      
                  # 获取环境变量（带空值保护）
                  changed_files = os.environ.get('CHANGED_FILES',  '').split()
                  print(f"[DEBUG] 变更文件列表: {changed_files}")
                  
                  relevant_configs = set()
                  
                  # 三级匹配验证 
                  for config_file, patterns in config_mappings.items(): 
                      for pattern in patterns:
                          pattern_clean = pattern.strip() 
                          for file in changed_files:
                              if fnmatch.fnmatch(file,  pattern_clean):
                                  print(f"[MATCH] {file} => {config_file} (模式: {pattern_clean})")
                                  relevant_configs.add(config_file) 
                                  break  # 匹配到即跳出当前模式循环 
                          if config_file in relevant_configs:
                              break  # 已匹配则跳过其他模式 
                              
                  # 输出结果验证 
                  if not relevant_configs:
                      print("[WARNING] 未匹配到任何配置文件")
                      
                  print(json.dumps(list(relevant_configs),  indent=2))
                  
              except json.JSONDecodeError as e:
                  print(f"[ERROR] JSON解析失败: {str(e)}")
                  sys.exit(1) 
              except Exception as e:
                  print(f"[ERROR] 执行异常: {str(e)}")
                  sys.exit(1) 
           
          if __name__ == "__main__":
              main()
          PYTHON_EOF 
       
          # 执行脚本并生成结果文件 
          python3 $SCRIPT_FILE > relevant_configs.json  
          EXIT_CODE=$?
          
          # 错误处理机制 
          if [ $EXIT_CODE -ne 0 ]; then 
              echo "::error::配置文件分析失败，错误码: $EXIT_CODE"
              rm -f $SCRIPT_FILE 
              exit $EXIT_CODE 
          fi 
          
          # 结果文件验证 
          if [ ! -s relevant_configs.json  ]; then 
              echo "::warning::生成的配置文件为空"
              echo "[]" > relevant_configs.json  
          fi 
          
          # 输出调试信息 
          echo "生成的配置文件内容："
          jq . relevant_configs.json  
          
          # 写入输出变量（带格式验证）
          json_content=$(jq -c . relevant_configs.json) 
          echo "config_files=${json_content}" >> $GITHUB_OUTPUT 
          
          # 清理临时文件 
          rm -f $SCRIPT_FILE 

  test:
    runs-on: ubuntu-22.04
    name: ${{ matrix.platform.UTEST }}-${{ matrix.platform.KERNEL }} - ${{ matrix.config_file }}
    strategy:
      fail-fast: false
      matrix:
        platform:
          - { UTEST: "qemu-a9",    RTT_BSP: "bsp/qemu-vexpress-a9",    QEMU_ARCH: "arm",     QEMU_MACHINE: "vexpress-a9", SD_FILE: "sd.bin", RUN: "yes", KERNEL: "standard" }
          - { UTEST: "qemu-riscv",   RTT_BSP: "bsp/qemu-virt64-riscv",   QEMU_ARCH: "riscv64", QEMU_MACHINE: "virt",        SD_FILE: "None",   RUN: "yes", KERNEL: "standard" }
          - { UTEST: "qemu-aarch64", RTT_BSP: "bsp/qemu-virt64-aarch64", QEMU_ARCH: "aarch64", QEMU_MACHINE: "virt",        SD_FILE: "sd.bin", RUN: "yes", KERNEL: "rtsmart" }
        config_file: ${{ fromJson(needs.prepare.outputs.config_files) }}

    env:
      TEST_QEMU_ARCH: ${{ matrix.platform.QEMU_ARCH }}
      TEST_QEMU_MACHINE: ${{ matrix.platform.QEMU_MACHINE }}
      TEST_BSP_ROOT: ${{ matrix.platform.RTT_BSP }}
      TEST_CONFIG_FILE: ${{ matrix.config_file }}
      TEST_SD_FILE: ${{ matrix.platform.SD_FILE }}
    steps:
      - uses: actions/checkout@v4

      - name: Install Tools
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get -yqq install scons qemu-system git
          pip3 install kconfiglib

      - name: Install ToolChains
        shell: bash
        run: |
          TOOLCHAIN_INSTALLED=""

          # Install Arm ToolChains
          if [[ "${{ matrix.platform.QEMU_ARCH }}" == "arm" && "${{ matrix.config_file }}" != "rtsmart/rtsmart.cfg" ]]; then
            echo "Starting install Arm ToolChains"
            wget -q https://github.com/RT-Thread/toolchains-ci/releases/download/v1.3/gcc-arm-none-eabi-10-2020-q4-major-x86_64-linux.tar.bz2
            sudo tar xjf gcc-arm-none-eabi-10-2020-q4-major-x86_64-linux.tar.bz2 -C /opt
            /opt/gcc-arm-none-eabi-10-2020-q4-major/bin/arm-none-eabi-gcc --version
            echo "RTT_EXEC_PATH=/opt/gcc-arm-none-eabi-10-2020-q4-major/bin" >> $GITHUB_ENV
            echo "RTT_CC_PREFIX=arm-none-eabi-" >> $GITHUB_ENV
            echo "TOOLCHAIN_INSTALLED=arm" >> $GITHUB_ENV
          fi

          # Install Arm Musl ToolChains
          if [[ "${{ matrix.platform.QEMU_ARCH }}" == "arm" && "${{ matrix.config_file }}" == "rtsmart/rtsmart.cfg" ]]; then
            echo "Starting install Arm Musl ToolChains"
            wget -q https://github.com/RT-Thread/toolchains-ci/releases/download/v1.7/arm-linux-musleabi_for_x86_64-pc-linux-gnu_stable.tar.bz2
            sudo tar xjf arm-linux-musleabi_for_x86_64-pc-linux-gnu_stable.tar.bz2 -C /opt
            /opt/arm-linux-musleabi_for_x86_64-pc-linux-gnu/bin/arm-linux-musleabi-gcc --version
            echo "RTT_EXEC_PATH=/opt/arm-linux-musleabi_for_x86_64-pc-linux-gnu/bin" >> $GITHUB_ENV
            echo "RTT_CC_PREFIX=arm-linux-musleabi-" >> $GITHUB_ENV
            echo "TOOLCHAIN_INSTALLED=arm-musl" >> $GITHUB_ENV
          fi

          # Install RISC-V ToolChains
          if [[ "${{ matrix.platform.QEMU_ARCH }}" == "riscv64" && "${{ matrix.config_file }}" != "rtsmart/rtsmart.cfg" ]]; then
            echo "Starting install RISC-V ToolChains"
            wget -q https://github.com/RT-Thread/toolchains-ci/releases/download/v1.4/riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86_64-linux-ubuntu14.tar.gz
            sudo tar zxvf riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86_64-linux-ubuntu14.tar.gz -C /opt
            /opt/riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86_64-linux-ubuntu14/bin/riscv64-unknown-elf-gcc --version
            echo "RTT_EXEC_PATH=/opt/riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86_64-linux-ubuntu14/bin" >> $GITHUB_ENV
            echo "TOOLCHAIN_INSTALLED=riscv" >> $GITHUB_ENV
          fi

          # Install RISC-V Musl ToolChains
          if [[ "${{ matrix.platform.QEMU_ARCH }}" == "riscv64" && "${{ matrix.config_file }}" == "rtsmart/rtsmart.cfg" ]]; then
            echo "Starting install RISC-V Musl ToolChains"
            wget -q https://github.com/RT-Thread/toolchains-ci/releases/download/v1.7/riscv64-linux-musleabi_for_x86_64-pc-linux-gnu_latest.tar.bz2
            sudo tar xjf riscv64-linux-musleabi_for_x86_64-pc-linux-gnu_latest.tar.bz2 -C /opt
            /opt/riscv64-linux-musleabi_for_x86_64-pc-linux-gnu/bin/riscv64-unknown-linux-musl-gcc --version
            echo "RTT_EXEC_PATH=/opt/riscv64-linux-musleabi_for_x86_64-pc-linux-gnu/bin" >> $GITHUB_ENV
            echo "RTT_CC_PREFIX=riscv64-unknown-linux-musl-" >> $GITHUB_ENV
            echo "TOOLCHAIN_INSTALLED=riscv-musl" >> $GITHUB_ENV
          fi

          # Install AARCH64 Musl ToolChains
          if [[ "${{ matrix.platform.QEMU_ARCH }}" == "aarch64" && "${{ matrix.config_file }}" == "rtsmart/rtsmart.cfg" ]]; then
            echo "Starting install AARCH64 Musl ToolChains"
            wget -q https://github.com/RT-Thread/toolchains-ci/releases/download/v1.7/aarch64-linux-musleabi_for_x86_64-pc-linux-gnu_stable.tar.bz2
            sudo tar xjf aarch64-linux-musleabi_for_x86_64-pc-linux-gnu_stable.tar.bz2 -C /opt
            /opt/aarch64-linux-musleabi_for_x86_64-pc-linux-gnu/bin/aarch64-linux-musleabi-gcc --version
            echo "RTT_EXEC_PATH=/opt/aarch64-linux-musleabi_for_x86_64-pc-linux-gnu/bin" >> $GITHUB_ENV
            echo "RTT_CC_PREFIX=aarch64-linux-musleabi-" >> $GITHUB_ENV
            echo "TOOLCHAIN_INSTALLED=aarch64-musl" >> $GITHUB_ENV
          fi

          # Install CPP11 Preprocessing Toolchain
          if [[ "${{ matrix.platform.QEMU_ARCH }}" == "arm" && "${{ matrix.config_file }}" == "cpp11/cpp11.cfg" ]]; then
            sudo rm -f /opt/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/c++/10.2.1/thread
            sudo rm -f /opt/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/c++/10.2.1/mutex
            sudo rm -f /opt/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/c++/10.2.1/condition_variable
            sudo rm -f /opt/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/c++/10.2.1/future
            sudo rm -f /opt/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/pthread.h
            sudo cat /dev/null > /opt/gcc-arm-none-eabi-10-2020-q4-major/arm-none-eabi/include/sys/_pthreadtypes.h
            sed -i 's/-fno-exceptions/ /g' $TEST_BSP_ROOT/rtconfig.py
          fi

          if [ "$TOOLCHAIN_INSTALLED" == "None" ]; then
            echo "No valid toolchain installed, stopping the workflow."
          fi

      - name: Build BSP
        if: ${{ matrix.platform.RUN == 'yes' && env.TOOLCHAIN_INSTALLED != '' && success() }}
        run: |
          echo CONFIG_RT_USING_UTESTCASES=y >> $TEST_BSP_ROOT/.config
          cat .github/utest/$TEST_CONFIG_FILE >> $TEST_BSP_ROOT/.config
          scons --pyconfig-silent -C $TEST_BSP_ROOT
          scons -j$(nproc) --strict -C $TEST_BSP_ROOT

      - name: QEMU Run Test
        if: ${{ matrix.platform.RUN == 'yes' && env.TOOLCHAIN_INSTALLED != '' && success() }}
        run: |
          if [ "$TEST_SD_FILE" != "None" ]; then
            dd if=/dev/zero of=$TEST_BSP_ROOT/sd.bin bs=1024 count=65536
            mkfs.fat $TEST_BSP_ROOT/sd.bin
          fi

          if [[ "${{ matrix.platform.QEMU_ARCH }}"  == "aarch64" ]]; then 
            qemu-system-$TEST_QEMU_ARCH -M virt,gic-version=2 -cpu cortex-a53 -smp 4 -kernel $TEST_BSP_ROOT/rtthread.bin  -nographic \
            -drive if=none,file=$TEST_BSP_ROOT/sd.bin,format=raw,id=blk0 -device virtio-blk-device,drive=blk0,bus=virtio-mmio-bus.0 \
            -netdev user,id=net0 -device virtio-net-device,netdev=net0,bus=virtio-mmio-bus.1 \
            > qemu_output_$TEST_QEMU_ARCH.log  2>&1 &
          elif [[ "${{ matrix.platform.QEMU_ARCH }}"  == "arm" ]]; then 
            qemu-system-$TEST_QEMU_ARCH \
                -nographic \
                -M $TEST_QEMU_MACHINE \
                -kernel $TEST_BSP_ROOT/rtthread.bin  \
                -sd $TEST_BSP_ROOT/sd.bin  \
                > qemu_output_$TEST_QEMU_ARCH.log  2>&1 &
          else 
            qemu-system-$TEST_QEMU_ARCH \
                -nographic \
                -M $TEST_QEMU_MACHINE \
                -kernel $TEST_BSP_ROOT/rtthread.bin  \
                > qemu_output_$TEST_QEMU_ARCH.log  2>&1 &
          fi 

          QEMU_PID=$!
          disown $QEMU_PID
      
      - name: Monitor qemu log
        if: ${{ matrix.platform.RUN == 'yes' && env.TOOLCHAIN_INSTALLED != '' && success() }}
        run: |
          FAILURE_DETECTED=false
          ERROR_LOGS=""
          
          tail -n 0 -f qemu_output_$TEST_QEMU_ARCH.log | while read line; do
            echo $line
            if [[ "$line" == *"[  FAILED  ] [ result   ]"* ]]; then
              ERROR_LOGS="$ERROR_LOGS$line"$'\n'
              FAILURE_DETECTED=true
            fi
            
            if [[ "$line" == *"[==========] [ utest    ] finished"* ]]; then
              if $FAILURE_DETECTED; then
                echo "Error: Failures detected in logs. Below are the failure details..."
                echo "$ERROR_LOGS"
                exit 1
              fi
              echo "Utest run completed. Exiting log monitoring..."
              break
            fi
          done
