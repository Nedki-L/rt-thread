name: PR Review Commenter

on:
  pull_request:
    types: [opened, synchronize, reopened]  # 当PR打开、更新或重新打开时触发

jobs:
  review-comment:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Install necessary dependencies
      - name: Install jq and GitHub CLI
        run: |
          sudo apt-get update
          sudo apt-get install -y jq gh curl

      # Step 3: Fetch modified files from the PR
      - name: Fetch modified files for the PR
        id: fetch-pr-files
        run: |
          echo "Fetching modified files for the PR..."
          PR_FILES=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files" \
            | jq -r '.[].filename' | tr '\n' ' ')

          echo "Modified files: $PR_FILES"
          echo "modified_files=$PR_FILES" >> $GITHUB_ENV

      # Step 4: Parse MAINTAINER.json and check file tags
      - name: Parse MAINTAINER.json and determine reviewers
        id: parse-maintenancer-json
        run: |
          echo "Parsing MAINTAINER.json and determining reviewers..."

          # Initialize variables
          MODIFIED_FILES="${{ env.modified_files }}"
          REVIEWERS_LIST=""
          COMMENT_BODY=""
          
          # Convert the modified files string into an array
          MODIFIED_FILES_ARRAY=($MODIFIED_FILES)

          echo "Initialize variables"

          # Read the MAINTAINER.json file and parse each tag's information
          jq -c '.[]' MAINTAINER.json | while IFS= read -r tag_info; do
            # Extract tag, path, and owner information from the JSON
            tag=$(echo $tag_info | jq -r '.tag')
            path=$(echo $tag_info | jq -r '.path')
            owners=$(echo $tag_info | jq -r '.owner')

            echo "Processing tag: $tag, path: $path, owners: $owners"

            # Check if any modified file matches the path (flexible matching)
            for file in "${MODIFIED_FILES_ARRAY[@]}"; do
              # Check if the file is in the directory or matches the tag path
              # Here we are allowing for recursive directory matching (e.g. /src -> matches src/*)
              if [[ "$file" == $path/* ]] || [[ "$file" == $path ]]; then
                echo "File $file matches tag $tag"

                # Collect reviewers for this tag
                IFS=', ' read -r -a owner_array <<< "$owners"
                reviewers=""
                for owner in "${owner_array[@]}"; do
                  reviewer="@$(echo $owner | cut -d'(' -f1)"
                  reviewers="$reviewers $reviewer"
                done

                # Prepare the comment for this tag
                TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
                COMMENT_BODY+="\nTimestamp: $TIMESTAMP\nReviewer: $reviewers\n\nTag: $tag\nPlease take a review of this tag\n"
              else
                echo "File $file does not match tag $tag"
              fi
            done
          done

          # Debug: Print the comment body for review
          echo "Generated COMMENT_BODY: $COMMENT_BODY"

          # Check if COMMENT_BODY is empty
          if [[ -z "$COMMENT_BODY" ]]; then
            echo "No relevant files modified, skipping comment creation."
            exit 0
          fi

          # Set the reviewers and comment body as output variables
          echo "comment_body=$COMMENT_BODY" >> $GITHUB_ENV
          echo "Reviewers determined: $COMMENT_BODY"

      # Step 5: Create or update CI review comment
      - name: Create or update CI comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Use the GITHUB_TOKEN as the environment variable for gh
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          COMMENT_BODY="${{ env.comment_body }}"

          # Check if COMMENT_BODY is empty before proceeding
          if [[ -z "$COMMENT_BODY" ]]; then
            echo "No relevant files modified, skipping comment creation."
            exit 0
          fi

          # Fetch existing comments and check if a CI bot comment exists
          COMMENTS=$(gh pr view $PR_NUMBER --json comments -q ".comments")
          
          # Check if there's an existing CI bot comment
          EXISTING_COMMENT=$(echo "$COMMENTS" | jq -r '.[] | select(.user.login=="github-actions[bot]") | .id' || true)

          if [[ -n "$EXISTING_COMMENT" ]]; then
            echo "Updating existing CI bot comment."
            gh pr comment $PR_NUMBER --body "$COMMENT_BODY" --comment-id $EXISTING_COMMENT
          else
            echo "Creating new CI bot comment."
            gh pr comment $PR_NUMBER --body "$COMMENT_BODY"
          fi
